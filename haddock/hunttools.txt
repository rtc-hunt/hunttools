-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A collection of tools for doing mystery hunt puzzles.
@package hunttools
@version 0.1.0.0


module Scrabble

-- | A map of scrabble letter to score for english.
englishPoints :: Map Char Int

-- | a synonym for <a>englishPoints</a>
points :: Map Char Int


module Pipe
($|) :: t1 -> (t1 -> t) -> t
infixl 0 $|


module MergeDawg
mergeDAWG :: Node -> Node -> Node
buildHugeDAWG :: [String] -> Node
mergeDawgNew :: [Node] -> [Word64]
mergeToHandle :: Handle -> [Node] -> IO ()
mergeToVector :: [Node] -> IO Node


module Elements

-- | Record for a particular element.
data ElementData
ElementData :: Int -> String -> String -> ElementData
[atomicNumber] :: ElementData -> Int
[symbol] :: ElementData -> String
[name] :: ElementData -> String
numberToSymbolMap :: Map Int String
numberToSymbol :: Int -> String
symbolToNumberMap :: Map String Int
symbolToNumber :: String -> Int
elementData :: [ElementData]
instance GHC.Read.Read Elements.ElementData
instance GHC.Show.Show Elements.ElementData


module DBPedia
runDBPedia :: String -> [String]
defaultDBPQuery :: String


-- | Core regex-like dictionary search; we implement a simple glob-like
--   pattern, and nondeterministic retrieval from a trie structure to
--   minimize cost.
--   
--   <ul>
--   <li>Examples</li>
--   </ul>
--   
--   <pre>
--   &gt;&gt;&gt; crossword onelook "j???l??p??a?d"
--   ["jeanlucpicard", ...]
--   </pre>
module Crossword

-- | A typeclass of types we can use as a crossword query.
--   
--   finalizeQuery and finalizeQueryStraight are probably going to merge
--   into a single getQueryParts function. The distinction now is that
--   finalizeQuery produces a query appropriate for a
--   <a>BidirectionalDictionary</a>, while finalizeQueryStraight produces a
--   query appropriate for a <a>ForwardDictionary</a>.
class CrosswordQuery a

-- | Run the given query against a crossword dictionary. This is the
--   primary entry point for this module.
crossword :: (CrosswordQuery a) => CrosswordDictionary -> a -> [String]

-- | Treat the input as a raw string, and query for subsequences of that
--   string in the dictionary. Does not have metacharacters, and
--   essentially wraps every letter in an individual <a>Opt</a>.
crosswordSubseq :: CrosswordDictionary -> [Char] -> [[Char]]
data QueryPart

-- | A literal string of characters. This could equivalently be written
--   with as a Literal Char type, but we chose to simplify the QueryPart
--   level of the representation.
Literal :: String -> QueryPart

-- | Matches zero-or-more arbitrary characters. Notably, this is <b>not</b>
--   the kleene star; in regex terms it's .*. * is parsed to Glob.
Glob :: QueryPart

-- | Exactly one arbitrary character. Named after regex dot, but we parse ?
--   to it following shell and crossword-solver conventions.
Dot :: QueryPart

-- | Character sets; matches exactly one of any of the given characters.
--   Not available from the string-to-query parser.
Charset :: [Char] -> QueryPart

-- | Kleene star. Not available from the string-to-query parser.
Star :: QueryPart -> QueryPart

-- | FIXME: what does this do again?
Opt :: String -> QueryPart

-- | A crossword dictionary.
data CrosswordDictionary

-- | A dictionary that has been munged to allow starting in the middle of
--   the word; see <a>optimizeInitialLiteral</a> in the source for details.
BidirectionalDictionary :: Node -> CrosswordDictionary

-- | A dictionary that is a simple trie of the words in the dictionary.
ForwardDictionary :: Node -> CrosswordDictionary
buildDict :: [String] -> Node
buildDictAscSplit :: [String] -> Node
buildDictUnidir :: [String] -> Node
getCrosswordDAWG :: CrosswordDictionary -> Node
instance GHC.Show.Show Crossword.QueryPart
instance Crossword.CrosswordQuery [GHC.Types.Char]
instance Crossword.CrosswordQuery [Crossword.QueryPart]


-- | Currently all that's here are rot n-related ciphers, but more to be
--   added.
module Cipher

-- | rotN cipher.
rot :: Int -> [Char] -> [Char]

-- | Brute-force a rotN cipher, by showing a list of each rotation. If
--   there's a correct answer, it should be easy enough to pick out by eye.
rotAll :: [Char] -> [[Char]]


module AnswerChecker

-- | Check an answer, assuming that it follows <i>exactly</i> the
--   puzzle-solution CSS class and uppercase pattern.
checkAnswer :: String -> String -> Correctness

-- | Pattern match against the given answer, in uppercase, on it's own
--   within any pair of HTML tags. Can leak answer information, use only if
--   confident and <a>checkAnswer</a> doesn't work.
checkAnswerFuzzy :: String -> String -> ByteString

-- | Simple "are you correct?" type, with a <a>Show</a> instance.
data Correctness
CORRECT :: Correctness
INCORRECT :: Correctness
NONEXISTANT :: Correctness
instance GHC.Show.Show AnswerChecker.Correctness


-- | Core anagram toolkit. The main entry points are <a>anagram</a>,
--   <a>anagramAny</a>, <a>anagramMin</a>, <a>anagramFull</a>, and
--   <a>anagramExact</a>. <a>Histogram</a>s are the internal form for
--   anagram queries, and are a count of how many of each letter is present
--   in the query.
--   
--   <h1>Examples</h1>
--   
--   <pre>
--   &gt;&gt;&gt; anagram ukacd "eoynkm"
--   ["monkey", "mekon", "money", ... "yon"]
--   
--   &gt;&gt;&gt; anagramAny ukacd "eoynkm"
--   ["monkey", "mekon", "money", ... "me", "mo", "my", ... "n", "o", "y"]
--   
--   &gt;&gt;&gt; anagramFull ukacd "eoynkm"
--   ["monkey"]
--   
--   &gt;&gt;&gt; anagramMin ukacd "eoynkm" 5
--   ["monkey", "mekon", "money"]
--   
--   &gt;&gt;&gt; anagramExact ukacd 5 "eoynkm"
--   ["mekon", "money"]
--   
--   &gt;&gt;&gt; anagramFull ukacd "?eoynk"
--   ["donkey","monkey","orkney","unyoke","yonker"]
--   </pre>
--   
--   We can also use the Histogram type directly, if that happens to be
--   convenient:
--   
--   <pre>
--   &gt;&gt;&gt; Histogram 9 (replicate 26 1)
--   histogramFromPairs 9 [('a',1),('b',1),('c',1),('d',1),('e',1),('f',1),('g',1),('h',1),('i',1),
--     ('j',1),('k',1),('l',1),('m',1),('n',1),('o',1),('p',1),('q',1),('r',1),('s',1),('t',1),
--     ('u',1),('v',1),('w',1),('x',1),('y',1),('z',1)]
--   
--   &gt;&gt;&gt; anagramFull onelook (Histogram 9 (replicate 26 1))
--   ["thequickbrownfoxjumpsoverthelazydog"]
--   </pre>
module Anagram

-- | A typeclass for things that can be treated as anagram queries.
--   
--   Currently, there is a <a>String</a> instance (so you can use bare
--   strings; also known as [<a>Char</a>]) and a <a>Histogram</a> instance,
--   to allow lower-level access through the same functions.
class Anagrammable a

-- | Get the query in the form of a Histogram, to actually use to access an
--   anagram dictionary.
getHistogram :: Anagrammable a => a -> Histogram

-- | Basic anagram. Constrains the set of returned anagrams to use between
--   half and all of the letters in the query.
anagram :: (Anagrammable a) => AnagramDictionary -> a -> [String]

-- | As <a>anagram</a>, but from all to none of the letters in the query.
anagramAny :: (Anagrammable a) => AnagramDictionary -> a -> [String]

-- | Anagram all the letters in the query.
--   
--   <pre>
--   anagramFull dict query = anagramMin dict query (length query)
--   </pre>
anagramFull :: (Anagrammable a) => AnagramDictionary -> a -> [String]

-- | Anagram at-least-k letters from the query.
--   
--   <pre>
--   anagram dict query = anagramMin dict (length query / 2) query
--   </pre>
--   
--   <pre>
--   anagramAny dict query = anagramMin dict 0 query 0
--   </pre>
anagramMin :: (Anagrammable a) => AnagramDictionary -> Int -> a -> [String]

-- | Anagram exactly k letters from the query.
--   
--   <pre>
--   all (\a-&gt;length a == k) (anagramExact dict k query)
--   </pre>
anagramExact :: (Anagrammable a) => AnagramDictionary -> Int -> a -> [String]

-- | The Histogram type; we implement anagram queries by converting the
--   string to one of these, and querying the database for matches.
data Histogram
Histogram :: Int -> [Int] -> Histogram

-- | We differentiate internally between real letters and wildcards; the
--   underlying code has to deal with them fully differently.
[blankCount] :: Histogram -> Int

-- | the list of counts; the order is the same order as
--   <a>anagramSymbols</a>.
[fromHistogram] :: Histogram -> [Int]

-- | The list of symbols we support anagramming; anything not in this list
--   is simply dropped. We use a finite list so <a>Histogram</a> and
--   <a>AnagramDictionary</a> don't need to store actual characters.
anagramSymbols :: [Char]

-- | Get the query in the form of a Histogram, to actually use to access an
--   anagram dictionary.
getHistogram :: Anagrammable a => a -> Histogram

-- | Subtract a histogram from a histogram. "aabc" - "ab" = "ac"
subHistogram :: Histogram -> Histogram -> Histogram

-- | A dictionary structure for querying anagrams.
--   
--   Internally, this is just the same sort of trie structure as
--   <a>CrosswordDictionary</a>, but instead of storing actual characters
--   we treat the members as <tt>Word8</tt>s of letter counts, followed by
--   the actual word. This allows us to eliminate common tails among the
--   given words essentially for free.
newtype AnagramDictionary
AnagramDictionary :: Node -> AnagramDictionary

-- | Construct an anagram dictionary from a raw list of strings. Gets very
--   slow on large dictionaries, due to the time to construct the trie.
buildAnagramDictionary :: [[Char]] -> AnagramDictionary

-- | Get the raw trie from an AnagramDictionary.
fromAnagramDictionary :: AnagramDictionary -> Node
instance GHC.Show.Show Anagram.Histogram
instance Anagram.Anagrammable [GHC.Types.Char]
instance Anagram.Anagrammable Anagram.Histogram


-- | FIXME: figure out how to teach how to use this.
module ConsumptiveMonad
type QConsumer q a = ListT (State q) a
runQC :: q -> QConsumer q a -> [a]
complete :: (IsQuery a, Eq a, Alternative m, MonadState a m) => b -> m b
class IsQuery a
(<\\>) :: IsQuery a => a -> String -> a
toQuery :: IsQuery a => String -> a
consumer :: IsQuery q => (q -> [String]) -> QConsumer q String
instance ConsumptiveMonad.IsQuery GHC.Base.String
instance ConsumptiveMonad.IsQuery Anagram.Histogram
instance Control.Monad.State.Class.MonadState s m => Control.Monad.State.Class.MonadState s (ListT.ListT m)
instance (GHC.Show.Show a, ConsumptiveMonad.IsQuery s) => GHC.Show.Show (ConsumptiveMonad.QConsumer s a)


-- | We use a simple return type polymorphism mechanism to select the
--   appropriate data structure for the query, so we have things like
--   <tt>ukacd :: (DictionaryContext a) =&gt; a</tt> where <tt>a</tt> can
--   be either CrosswordDictionary or AnagramDictionary. The definition for
--   ukacd is then something like
--   
--   <pre>
--   ukacd = fromDictionary $ Dictionary (AnagramDictionary $ fromFile "ukacd-anagram.dawg") (Crossword.BidirectionalDictionary $ fromFile "ukacd-cross.dawg")
--   </pre>
--   
--   (not literally that, there are some unsafePerformIO (We know that
--   these files are effectively large constants), "where is this file
--   installed", etc. steps, but that is roughly the correct intuition.)
module Dictionary

-- | Effectively, a Dictionary object consists of a copy of the dictionary
--   structured for anagrams and the same dictionary structured for
--   crossword queries. If we find that there are more data structures that
--   are useful and we want all the dictionaries in, we can add them here
--   (and add an appropriate <a>DictionaryContext</a> instance).
data Dictionary
Dictionary :: AnagramDictionary -> CrosswordDictionary -> Dictionary
[anaDict] :: Dictionary -> AnagramDictionary
[crossDict] :: Dictionary -> CrosswordDictionary

-- | A context that we might want to have a specialized dictionary
--   representation for.
class DictionaryContext a
fromDictionary :: DictionaryContext a => Dictionary -> a
fromDictionary :: DictionaryContext a => Dictionary -> a
instance Dictionary.DictionaryContext Crossword.CrosswordDictionary
instance Dictionary.DictionaryContext Anagram.AnagramDictionary
instance Dictionary.DictionaryContext Dictionary.Dictionary
